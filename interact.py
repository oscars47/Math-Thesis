# file to implement wormhole teleportation protocol using the SYK model, generated by syk.py

import numpy as np
import os

from syk import majorana

def get_H(N, one_random = True):
    '''Returns the SYK Hamiltonian for N qubits.
    Params:
        N: number of qubits
        one_random: if True, randomly selects one Hamiltonian from the H_N folder
    '''
    assert one_random, "Currently only one_random = True is supported"

    # get random state
    H_files = os.listdir('ham/H_{}'.format(N))
    H_file = np.random.choice(H_files)
    H = np.load('ham/H_{}/{}'.format(N, H_file), allow_pickle=True)

    return H

def init_TFD(H, beta = 4):
    '''Creates TFD state using an SYK Hamiltonian with N qubits.
    Params:
        H: SYK Hamiltonian
        beta: inverse temperature, given in the Jafferis paper as 4
    '''
    N = int(np.log2(H.shape[0]))

    # sum over 0 to 2^N - 1; take the tensor products of the column vectors and weight by e^{-beta E_n}
    TFD = np.zeros((2**(2*N), 1), dtype=np.complex128)

    for n in range(2**N):
        # get the nth column vector
        col = np.zeros((2**N, 1), dtype=np.complex128)
        col[n] = 1
        # get tensor prod
        col_t = np.kron(col, col)
        # the energy of the nth state is the eigenvalue of the nth column vector
        E_n = H[n][n]
        # weight by e^{-beta E_n}
        TFD += np.exp(-beta * E_n) * col_t
    # weight the whole thing by 1/sqrt(Z)
    TFD /= np.sqrt(np.sum(np.abs(TFD)**2))
    return TFD

def tev_TFD(t, TFD, H):
    '''Time-evolves the TFD state by t.'''
    # loop through all columns and multiply by e^{-i lamda_n t}
    N = int(np.log2(H.shape[0]))
    for n in range(2**N):
        col = TFD[n]
        # get the eigenvalue from H
        E_n = H[n][n]
        # multiply by e^{-i lamda_n t}
        TFD[n] = col * np.exp(-1j * E_n * t)
    return TFD

def neg_shockwave(TFD, mu = -12):
    '''Multiply the TFD by e^{imu V}'''
    # first define V in terms of tensor products of the majorana matrices from syk




